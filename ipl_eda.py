# -*- coding: utf-8 -*-
"""IPL-EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q-uzPhTII_rS2rcJO1fEyaZqYCK8KpVS

#About the Dataset

The Indian Premier League (IPL) a professional Twenty20 cricket league in India usually
contested between March and May of every year by eight teams representing eight different
cities or states in India. The league was founded by the Board of Control for Cricket in India
(BCCI) in 2007. The IPL is the most-attended cricket league in the world and the brand value of
the IPL in 2019 was 475 billion (US$6.7 billion)

# Dataset Link
The dataset consists of two files:
1. Deliveries Dataset:
https://drive.google.com/file/d/1O6E5DBDSFYSK4D9kandO-ELgFV23GVyi/view?usp=sharing
2. Match Dataset:
https://drive.google.com/file/d/1tfdKTH39s8bhpRbY_Sz5FYO6IRPoFoeG/view?usp=sharing

#Importing Necessary Libraries

We are required to importing the libraries so as to performing EDA. These include NumPy, Pandas, Matplotlib, and Seaborn.
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd # Pandas is a powerful library for data manipulation and analysis.
import numpy as np # NumPy is a powerful tool for numerical computations in Python.
import matplotlib.pyplot as plt  # Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python
import seaborn as sns # Seaborn is a statistical data visualization library based on Matplotlib
# %matplotlib inline

"""#DATA EXPLORATION

#Loading the Dataset

###The line df = pd.read_csv starts the process of reading a CSV file into a pandas DataFrame.
###This allows for easy data manipulation and analysis using pandas functionalities.
"""

ball = pd.read_csv("IPL Ball-by-Ball 2008-2020 (1).csv") #Reading the data from the file IPL Ball-by-Ball 2008-2020.csv

matches = pd.read_csv("IPL Matches 2008-2020 (1).csv") #Reading the data from the file IPL Matches 2008-2020.csv

ball.head() #Displays the first 5 rows of the Dataset

matches.head() #Displays the first 5 rows of the Dataset

len(ball)

"""The len() function in Python is used to determine the length (the number of items) of an object. Depending on the type of object passed to it, len() can return different types of lengths, such as the number of elements in a list, the number of characters in a string, or the number of key-value pairs in a dictionary"""

ball.info()

"""The info() method in pandas is used to quickly gather and display concise information about a DataFrame, including the index dtype, column dtypes, non-null values, and memory usage. This method is particularly useful for getting a quick overview of a DataFrame's structure and data types, which is essential for data cleaning and preprocessing.


"""

len(matches)

matches.info()

"""#Data Preprocessing

##Checking if there is any Null value in the Data
"""

ball.isnull().sum() #Displays the total count of the null values in the columns.

"""In ball dataset there are null values in the following columns:


* dismissal_kind   :  183973
* player_dismissed :  183973
* fielder          :  186684
* extras_type      :  183235
* bowling_team     :  191


"""

matches.isnull().sum() #Displays the total count of the null values in the columns.

"""In matches dataset there are null values in the following columns:



*   city: 13
*   player_of_match :     4
* winner        :       4
* result         :      4
* result_margin   :    17
* eliminator       :    4
* method            : 797

###In data analysis and data processing, missing values are a common issue. Handling these missing values is crucial because they can lead to errors or misleading results during data analysis. Pandas provides several methods to handle missing values, and fillna is one of the most frequently used methods.

###Imputation is the process of replacing missing data with substituted values. The fillna method is a simple imputation strategy where we substitute missing values with a specific value,

###Eg: which in this case is the string 'no_dismissal'

###By filling missing values with 'no_dismissal', we are ensuring that the dismissal_kind column does not contain any NaN values. This can be particularly useful for further analysis, modeling, or visualization, as it maintains data consistency and prevents potential issues arising from missing data
"""

ball['dismissal_kind'] = ball['dismissal_kind'].fillna('no_dismissal') #Filling the missing values with no_dismissal.

ball['player_dismissed'] = ball['player_dismissed'].fillna('no_player_dismissed') #Filling the missing values with no_player_dismissed.

ball['fielder'] = ball['fielder'].fillna('no_fielder') #Filling the missing values with no_fielder.

ball['extras_type'] = ball['extras_type'].fillna('no_extras_type') #Filling the missing values with no_extras_type.

ball['bowling_team'] = ball['bowling_team'].fillna('no_bowling_team') #Filling the missing values with no_bowling_team.

ball.isnull().sum()#Checking if still there is any null value the the ball dataset.

"""###The missing values are taken care, now there is not null or missing value in the ball dataset.

##Handeling the missing values of the matches dataset

###The code which is used below to identify the unique venues where matches were played in cases where the city information is missing.
"""

matches[matches['city'].isnull()]['venue'].unique()

"""This output indicates that the matches with missing city information were held at 'Sharjah Cricket Stadium' and 'Dubai International Cricket Stadium'."""

matches.loc[matches['venue'] == 'Sharjah Cricket Stadium', 'city'] #checking for the null values in the city column only with the venue Sharjah Cricket Stadium.

"""matches.loc[condition, 'city']: This uses the .loc accessor to select rows based on a condition (matches['venue'] == 'Sharjah Cricket Stadium') and then specifies that only the 'city' column should be returned for these rows."""

matches.loc[matches['venue'] == 'Dubai International Cricket Stadium', 'city'] #checking for the null values in the city column only with the venue Dubai International Cricket Stadium.

"""matches.loc[condition, 'city']: This uses the .loc accessor to select rows based on a condition (matches['venue'] == 'Dubai International Cricket Stadium') and then specifies that only the 'city' column should be returned for these rows."""

matches.loc[matches['venue'] == 'Sharjah Cricket Stadium', 'city'] = 'Sharjah' #Filling up the NaN values for the venue related to Sharjah Cricket Stadium.

"""matches.loc[condition, 'city'] = 'Sharjah': This uses the .loc accessor to directly update the 'city' column for rows where the 'venue' is 'Sharjah Cricket Stadium'. This way the null values will also be filled.

"""

matches.loc[matches['venue'] == 'Dubai International Cricket Stadium', 'city'] = 'Dubai' #Filling up the NaN values for the venue related to Dubai International Cricket Stadium.

"""matches.loc[condition, 'city'] = 'Dubai': This uses the .loc accessor to directly update the 'city' column for rows where the 'venue' is 'Dubai International Cricket Stadium'. This way the null values will also be filled."""

matches['player_of_match'].fillna('no_player_of_match', inplace=True) #Filling up the NaN values in the 'player_of_match' column with 'no_player_of_match'.

matches['winner'].fillna('no_winner', inplace=True) #Filling up the NaN values in the 'winner' column with 'no_winner'.

matches['result'].fillna('no_result', inplace=True) #Filling up the NaN values in the 'result' column with 'no_result'.

matches['result_margin'].fillna('no_result_margin', inplace=True) #Filling up the NaN values in the 'result_margin' column with 'no_result_margin'.

matches['eliminator'].fillna('no_eliminator', inplace=True) #Filling up the NaN values in the 'eliminator' column with 'no_eliminator'.

matches['method'].fillna('no_method', inplace=True) #Filling up the NaN values in the 'method' column with 'no_method'.

matches.isnull().sum() #Checking if still there are any missing values in the matches dataset.

"""Now we can see that the there is no missing value in the matches dataset.

#Q1) What was the count of matches played in each season?

As we can see in the dataframe there is no season column specifically with the years mentioned. We have the data column with contains the data-month-year. So we are required to extract only the year from the date column, so that we can find the number of matches played in each year/season.
"""

matches['date'] = pd.to_datetime(matches['date'])#we have to Convert 'date' column to datetime type so that the pandas dataframe can read it.


matches['Season'] = matches['date'].dt.year # Extract year and assign to 'Season' column

matches.head()

"""Now we can check that the season column is added so that we can check for details only pertaining to the years."""

match_per_season = matches.groupby('Season').size().reset_index(name='matchess')

"""###groupby('Season'): Groups the data by the 'Season' column.
###size(): Counts the number of occurrences in each group.
###reset_index(name='matches'): Resets the index and renames the resulting column to 'matches'.
"""

match_per_season #Displays the data.

"""###As we can see see the average matches per season is 60, however there is a spike in number of matches from 2011 to 2013

"""

from matplotlib import pyplot as plt
match_per_season['Season'].plot(kind='hist', bins=20, title='Season')
plt.gca().spines[['top', 'right',]].set_visible(False)

"""#Q2) How many runs were scored in each season?

####The runs column is in the 'ball' dataset and the season column is in the 'matches' dataset, so we have to merge some columns of the 'matches' dataset to the 'ball' dataset to get the runs scored in each season.
"""

season_data = matches[['id', 'date', 'Season']].merge(ball, on='id', how='left').drop(columns='id')
season_data.head()

"""###matches[['id', 'date', 'Season']]: Selects the 'id', 'date', and 'Season' columns from the matches DataFrame.
###.merge(ball_data, on='id', how='left'): Merges the selected columns with ball on the 'id' column using a left join.
###.drop(columns='id'): Drops the 'id' column from the merged DataFrame.
###season_data.head(): Displays the first few rows of the resulting DataFrame.
"""

runs_per_season = season_data.groupby('Season')['total_runs'].sum().reset_index()

"""###season_data.groupby('Season')['total_runs'].sum(): Groups the merged data by 'Season' and sums the 'runs' for each season.
###.reset_index(): Resets the index to get a clean DataFrame.
"""

runs_per_season #Stores the result in a DataFrame and displays it

import plotly.express as px

Season = season_data.groupby(['Season'])['total_runs'].sum().reset_index()
p = Season.set_index('Season')
fig = px.line(p, x=p.index, y="total_runs")
fig.update_layout(title="Total Runs Across the Seasons ",
                  titlefont={'size': 26},template='simple_white'  )

fig.show()

"""###Season 2013 was the highest scoring season (22,541 runs), followed by 2012 (22,453 runs)
###Season 2009 was the lowest scoring season (16,320 runs).

#Q3) What were the runs scored per match in different seasons?
"""

# Combine match counts and total runs into one DataFrame
runs_per_season = match_per_season.merge(Season[['Season', 'total_runs']], on='Season')

# Calculate runs scored per match
runs_per_season['Runs scored per match'] = runs_per_season['total_runs'] / runs_per_season['matchess']

# Set 'Season' as the index
runs_per_season.set_index('Season', inplace=True)

# Display the result
print(runs_per_season)

fig = px.line(runs_per_season, x=runs_per_season.index, y="Runs scored per match")
fig.update_layout(title="Runs scored per match across seasons",
                  titlefont={'size': 26},template='simple_white')
fig.show()

"""###In season 2018, runs scored per match was 331.683333 which was highest among others.
###In season 2009, runs scored per match was 286.315789 which was lowest.

#Q4) Who has umpired the most?
"""

# Concatenate 'umpire1' and 'umpire2' columns and count occurrences
ump = pd.concat([matches['umpire1'], matches['umpire2']]).value_counts()

# Convert the Series to a DataFrame and reset the index
umps = ump.reset_index(name='count')

# Display the top 10 umpires
print(umps.head(10))

"""###pd.concat([matches['umpire1'], matches['umpire2']]).value_counts(): Concatenates the 'umpire1' and 'umpire2' columns, then counts the occurrences of each umpire.
###ump.reset_index(name='count'): Converts the Series to a DataFrame and renames the count column to 'count'.

##S Ravi has umpired in 121 matches, followed by Dharmasena who has umpired in 94 matches.

#Q5) Which team has won the most tosses?
"""

matches['toss_winner'].value_counts() #code is used to count the occurrences of each unique value in the 'toss_winner' column of the matches DataFrame

import matplotlib.pyplot as plt

# Count the occurrences of each unique value in the 'toss_winner' column
toss_winner_counts = matches['toss_winner'].value_counts()

# Create a bar plot
plt.figure(figsize=(10, 6))
toss_winner_counts.plot(kind='bar')

# Set the title and labels
plt.title('Toss Winner Counts')
plt.xlabel('Team')
plt.ylabel('Count')

# Display the plot
plt.show()

"""###Mumbai Indians have won the most tosses, followed by Kolkata Knight Riders

#Q6) What does the team decide after winning the toss?
"""

toss_data = matches[['toss_winner', 'toss_decision']] #Extracting the columns that are relevant to the toss decision.

toss_data #Printing the columns

toss_decisions = toss_data['toss_decision'].value_counts() #Calculating the count of each decision (bat or field) made by the teams after winning the toss.
print(toss_decisions)

import matplotlib.pyplot as plt #Visualization via Bar Plot.

# Plotting the toss decisions
toss_decisions.plot(kind='bar', color=['skyblue', 'lightgreen'])
plt.title('Toss Decisions in IPL')
plt.xlabel('Decision')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.show()

"""After winning the toss most of the team choose to field first."""

import plotly.graph_objs as go #Visualization via graph.
temp_series = matches.toss_decision.value_counts()
labels = (np.array(temp_series.index))
values = (np.array((temp_series / temp_series.sum())*100))
colors = ['turquoise', 'crimson']
fig = go.Figure(data=[go.Pie(labels=labels,
                             values=values,hole=.3)])
fig.update_traces(hoverinfo='label+percent', textinfo='label+percent', textfont_size=20,
                  marker=dict(colors=colors, line=dict(color='#000000', width=3)))
fig.update_layout(title="Toss decision percentage",
                  titlefont={'size': 30},)

fig.show()

"""Here as we can check through the graph the 60.80% of the team choose to field first after winning the toss and 39.20% chose to bat first after winning the toss.

#Q7) How does the toss decision vary across seasons?
"""

matches.head()#Quick view at the dataset

toss_df = matches[['Season', 'toss_decision']] #Extract the columns that are relevant to the analysis.

toss_df #Printing the columns.

toss_decisions_by_season = toss_df.groupby(['Season', 'toss_decision']).size().unstack().fillna(0) # Groups the data by season and toss decision to see the count of each decision per season.
print(toss_decisions_by_season)

import matplotlib.pyplot as plt #Visualization of the data

# Plotting the toss decisions by season
toss_decisions_by_season.plot(kind='bar', stacked=True, figsize=(12, 8), color=['skyblue', 'lightgreen'])
plt.title('Toss Decisions Across IPL Seasons')
plt.xlabel('Season')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.legend(title='Toss Decision')
plt.show()

fig=px.histogram(data_frame=matches,x='Season',color='toss_decision',color_discrete_sequence=colors,barmode='group')
fig.update_layout(title="Toss decision in different seasons",
                  titlefont={'size': 26},template='simple_white'
                  )
fig.update_traces(marker_line_color='black',
                  marker_line_width=2.5, opacity=1)
fig.show()

"""Most of the times, teams decide to feild first except in season 2009,2010,2013 where teams decided to bat first mostly

#Q8) Does winning the toss imply winning the game?
"""

matches['toss_win_match_win'] = matches['toss_winner'] == matches['winner'] #Creating a new column that indicates whether the team that won the toss also won the match.

matches['toss_win_match_win']

"""###True = The team that won the toss also won the match.
###False = The team that won the toss did not win the match.
"""

matches.head()

toss_win_count = matches['toss_win_match_win'].sum()
total_matches = len(matches)
toss_win_percentage = (toss_win_count / total_matches) * 100

print(f"Matches won by toss winners: {toss_win_count}")
print(f"Total matches: {total_matches}")
print(f"Percentage of matches won by toss winners: {toss_win_percentage:.2f}%")

import matplotlib.pyplot as plt

labels = ['Won Toss and Match', 'Did Not Win Toss and Match']
sizes = [toss_win_count, total_matches - toss_win_count]
colors = ['skyblue', 'lightcoral']
explode = (0.1, 0)  # explode the first slice

plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=140)
plt.title('Impact of Winning Toss on Match Outcome')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.show()

"""Though winning toss gives you an advantage but it doesn't significantly implies that winning the toss helps in winning the game.

#Q9) How many times has the chasing team won the match?
"""

# Creating a column indicates which team batted first
matches['bat_first'] = matches.apply(
    lambda row: row['team1'] if row['toss_winner'] == row['team1'] and row['toss_decision'] == 'bat' else
                row['team2'] if row['toss_winner'] == row['team2'] and row['toss_decision'] == 'bat' else
                row['team2'] if row['toss_winner'] == row['team1'] and row['toss_decision'] == 'field' else
                row['team1'], axis=1)

# Creating a column indicating which team batted second (chased)
matches['bat_second'] = matches.apply(
    lambda row: row['team2'] if row['bat_first'] == row['team1'] else row['team1'], axis=1)

matches # checking the Dataframe for further analysis.

# Create a column indicating if the chasing team won
matches['chasing_team_won'] = matches['winner'] == matches['bat_second']

# Count the number of matches won by the chasing team
chasing_wins = matches['chasing_team_won'].sum()

print(f"Number of matches won by the chasing team: {chasing_wins}")

"""#Q10) Which all teams had won this tournament?"""

final_matches = matches.loc[matches.groupby('Season')['id'].idxmax()] #Filtering the dataset to identify the final match of each season, the final match will have the highest match ID for each season.

final_matches #quick view at the dataframe

tournament_winners = final_matches[['Season', 'winner']].reset_index(drop=True) #Extracting the winning team for each season from the final matches dataset.
print(tournament_winners)

"""###Here we can see the winner for the tournament for each season."""

colors = ['turquoise',] * 6
colors[0] = 'crimson'
fig=px.bar( y=tournament_winners['winner'].value_counts(),x=tournament_winners['winner'].value_counts().index,labels=dict(x="Team Name",y="Count"),)
fig.update_layout(title="Winners of IPL",
                  titlefont={'size': 26},template='simple_white'
                  )
fig.update_traces(marker_line_color='black',
                  marker_line_width=2.5, opacity=1,marker_color=colors)
fig.show()

"""###Here we can check the number of times a team has won the tournament

* Mumbai Indian = 5
* Chennai Super Kings = 3
* Kolkata Knight Riders = 2
* Rajasthan Royals = 1
* Deccan Chargers = 1
* Sunrisers Hyderabad = 1

#Q11)  Which team has played the most number of matches?

###As each match involves two teams, we'll need to count matches for both team1 and team2. A easy way to do this is to stack the teams and then count occurrences.
"""

team_counts = matches[['team1', 'team2']].stack().value_counts() #Stacking the teams into a single column and counting the occurrences.

team_counts.head(15) #checking the dataframe.

"""###Here we can check for the number of matches played by each team."""

# Display the team with the most matches
most_matches_team = team_counts.idxmax()
most_matches_count = team_counts.max()
print(f"The team with the most number of matches is {most_matches_team} with {most_matches_count} matches.")

import seaborn as sns
import matplotlib.pyplot as plt

# Convert to DataFrame for seaborn
team_counts_df = team_counts.reset_index()
team_counts_df.columns = ['Team', 'Matches']

# Plotting the number of matches played by each team using seaborn
plt.figure(figsize=(12, 6))
sns.barplot(x='Team', y='Matches', data=team_counts_df, palette='viridis')
plt.title('Number of Matches Played by Each Team')
plt.xlabel('Teams')
plt.ylabel('Number of Matches')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""#Q12)  Which team has won the most number of times?

###We can count the number of wins for each team using the winner column.
"""

win_counts = matches['winner'].value_counts() # Count the number of wins for each team

win_counts

most_wins_team = win_counts.idxmax()
most_wins_count = win_counts.max()

print(f"The team with the most number of wins is {most_wins_team} with {most_wins_count} wins.")# Display the team with the most wins

import matplotlib.pyplot as plt

# Plotting the number of wins by each team
plt.figure(figsize=(12, 6))
win_counts.plot(kind='bar', color='skyblue')
plt.title('Number of Wins by Each Team')
plt.xlabel('Teams')
plt.ylabel('Number of Wins')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Convert to DataFrame for seaborn
win_counts_df = win_counts.reset_index()
win_counts_df.columns = ['Team', 'Wins']

# Plotting the number of wins by each team using seaborn
plt.figure(figsize=(12, 6))
sns.barplot(x='Team', y='Wins', data=win_counts_df, palette='viridis')
plt.title('Number of Wins by Each Team')
plt.xlabel('Teams')
plt.ylabel('Number of Wins')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""###Mumbai Indians had won the most matches(120), followed by Chennai Super Kings (106)

#Q13) Which team has the highest winning percentage?

###To determine which team has the highest winning percentage in the IPL


*   Calculate total matches played: Count the total number of matches each team has played.
* Calculate total matches won: Count the total number of matches each team has won.
* Calculate winning percentage: Compute the winning percentage for each team.
* Visualize the winning percentage: Use a bar plot to visualize the winning percentages
"""

# Stack the teams into a single column and count the occurrences
matches_played = matches[['team1', 'team2']].stack().value_counts()

matches_played #Count the total number of matches each team has played.

# Count the number of wins for each team
matches_won = matches['winner'].value_counts()

matches_won #Count the total number of matches each team has won.

# Calculate the winning percentage
winning_percentage = (matches_won / matches_played) * 100
winning_percentage = winning_percentage.sort_values(ascending=False)

winning_percentage #Computing the winning percentage for each team.

import matplotlib.pyplot as plt
import seaborn as sns

# Convert to DataFrame for seaborn
winning_percentage_df = winning_percentage.reset_index()
winning_percentage_df.columns = ['Team', 'Winning Percentage']

# Plotting the winning percentage using seaborn
plt.figure(figsize=(12, 6))
sns.barplot(x='Team', y='Winning Percentage', data=winning_percentage_df, palette='viridis')
plt.title('Winning Percentage of Each Team')
plt.xlabel('Teams')
plt.ylabel('Winning Percentage')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""###Rising Pune Supergiants have the highest win % of 62.50, followed by Chennai Super kings and Mumbai Indians.

#Q14) Is there any lucky venue for a particular team?
"""

df_filtered = matches[['venue', 'winner', 'team1', 'team2']] #Extracting relevant columns.

# Count the number of wins for each team at each venue
win_counts = df_filtered.groupby(['venue', 'winner']).size().unstack(fill_value=0)

def lucky(match_data,team_name):
    return match_data[match_data['winner']==team_name]['venue'].value_counts().nlargest(10)

mi=lucky(matches,'Mumbai Indians')
values = mi
labels=mi.index
colors = ['turquoise', 'crimson']
fig = go.Figure(data=[go.Pie(labels=labels,values=values,hole=.3)])
fig.update_traces(hoverinfo='label+percent', textinfo='value', textfont_size=20,
                  marker=dict(colors=colors, line=dict(color='#000000', width=3)))
fig.update_layout(title="Wins at different Venues for MI:",
                  titlefont={'size': 30},
                  )
fig.show()

rcb=lucky(matches,'Royal Challengers Bangalore')
values = rcb
labels=rcb.index
colors = ['turquoise', 'crimson']
fig = go.Figure(data=[go.Pie(labels=labels,values=values,hole=.3)])
fig.update_traces(hoverinfo='label+percent', textinfo='value', textfont_size=20,
                  marker=dict(colors=colors, line=dict(color='#000000', width=3)))
fig.update_layout(title="Wins at different Venues for RCB:",
                  titlefont={'size': 30},
                  )
fig.show()

"""###It can be easily seen that team have won the most of its matches at their home venues

#Q15 Innings wise comparison between teams.

The purpose of applying this code is to summarize and analyze the runs scored by each batting team in each inning across multiple cricket matches ('id'). This kind of data aggregation is crucial for various analyses in cricket statistics and analytics, including:

Team Performance Analysis: Understanding how well each team performs in different innings across matches.
Comparative Analysis: Comparing the performance of different teams in terms of total runs scored.
Trend Analysis: Identifying patterns and trends in team performance over time or across different conditions (e.g., venues).
"""

runs=ball.groupby(['id','inning','batting_team'])[['total_runs']].sum().reset_index() #Grouping by ['id', 'inning', 'batting_team'] [['total_runs']].sum(): After grouping, this selects the 'total_runs' column and calculates the sum of runs ('total_runs') scored by each 'batting_team' in each 'inning' across all matches ('id').
runs.drop('id',axis=1,inplace=True) #The 'id' column, which was used for grouping purposes, is no longer needed in the final DataFrame (runs). Therefore, it is dropped using the drop() method
runs.head()

inning1=runs[runs['inning']==1]
inning2=runs[runs['inning']==2]

"""###The code snippet inning1 = runs[runs['inning'] == 1] and inning2 = runs[runs['inning'] == 2] is used to segment the DataFrame runs into two separate DataFrames based on the innings (1 and 2). This segmentation is crucial for detailed analysis and comparison of team performances across different phases of cricket matches."""

fig = px.box(y='total_runs',x='batting_team',data_frame=inning1,color='batting_team')

fig.update_layout(title="Batting First",
                  titlefont={'size': 26},template='simple_white'
                  )
fig.show()

"""###Royal Challengers Bangalore and Mumbai Indians median value is better than other teams while batting first."""

fig = px.box(y='total_runs',x='batting_team',data_frame=inning2,color='batting_team')

fig.update_layout(title="Batting Second",
                  titlefont={'size': 26},template='simple_white'
                  )
fig.show()

"""#Q16)  Which team has scored the most number of 200+ scores?"""

high_scores=ball.groupby(['id', 'inning','batting_team','bowling_team'])['total_runs'].sum().reset_index() #Here we are calling only the revelant columns.
score_200=high_scores[high_scores['total_runs']>=200] #From the total_runs columns we will only take the number which are equal to or more than 200.
score_200.head(5)

x1=score_200['batting_team'].value_counts() #calculates the number of times each team appears in the 'batting_team' column of the score_200 DataFrame and stores this as a Series in x1.
x1=pd.DataFrame(x1)#converts the Series x1 into a DataFrame, making it easier to work with and allowing for more advanced DataFrame operations if needed.
x1 #display it in a tabular format

colors = ['turquoise',] * 11
colors[0] = 'crimson'
fig=px.bar(x=x1.index,y=x1['count'],labels=dict(x="Team Name",y="Count"),)
fig.update_layout(title="Total count of 200+ by batting team",
                  titlefont={'size': 26},template='simple_white'
                  )
fig.update_traces(marker_line_color='black',
                  marker_line_width=2.5, opacity=1,marker_color=colors)
fig.show()

"""###Royal Challengers Bangalore had scored the most 200+ score (19 times), followed by Chennai Super Kings who had scored 17 times.

#Q17) Which team has conceded 200+ scores the most?

###The question "Which team has conceded 200+ scores the most?" asks for the team that has allowed its opponents to score 200 or more runs in a match most frequently. In the context of IPL cricket, this means finding out which team has had the most matches where the opposing team scored at least 200 runs.
"""

high_scores = score_200['bowling_team'].value_counts() #Extracts the 'bowling_team' column from the DataFrame score_200, Counts the occurrences of each unique value in this column. Assigns the resulting Series of counts to the variable high_scores

high_scores=pd.DataFrame(high_scores) #This constructor takes the input data and converts it into a DataFrame structure, providing functionality to manipulate and analyze the data easily.

high_scores #display it in a tabular format

colors = ['turquoise',] * 14
colors[0] = 'crimson'
fig=px.bar(x=high_scores.index,y=high_scores['count'],labels=dict(x="Team Name",y="Count"),)
fig.update_layout(title="Total count of 200+ conceded by bowling team",
                  titlefont={'size': 26},template='simple_white'
                  )
fig.update_traces(marker_line_color='black',
                  marker_line_width=2.5, opacity=1,marker_color=colors)
fig.show()

"""###Kings XI Punjab has conceded 200+ runs 20 times, followed by Royal Challengers Bangalore.

#Q18)  What was the highest run scored by a team in a single match?
"""

high_200 = ball.groupby(['id', 'inning', 'batting_team', 'bowling_team'])['total_runs'].sum().reset_index() #This groups the data by the specified columns and calculates the sum of total_runs for each group.

high_200.set_index(['id'], inplace=True) #This sets the id column as the index of the DataFrame.

high_200 #display it in a tabular format

max_row = high_200.loc[high_200['total_runs'].idxmax()]

batting_team = max_row['batting_team']
bowling_team = max_row['bowling_team']
max_total_runs = max_row['total_runs']

batting_team

bowling_team

max_total_runs

"""##In season 2013, Royal Challengers Bangalore scored 263/5 against Pune Warriors India.

#Q19) Which is the biggest win in terms of run margin?
"""

# Convert 'result_margin' column to numeric, setting errors='coerce' will turn non-numeric values into NaN
matches['result_margin'] = pd.to_numeric(matches['result_margin'], errors='coerce')

# Find the row with the maximum result_margin
max_margin_row = matches[matches['result_margin'] == matches['result_margin'].max()]

max_margin_row

"""###In season 2017, Mumbai Indians had defeated Delhi Daredevils by a huge margin of 146 runs.

#Q20) Which batsmen have played the most number of balls?
"""

balls_played=ball.groupby(['batsman'])['ball'].count().reset_index() #Groups the data by batsman and counts the number of balls each batsman has faced.
balls_played.sort_values(by='ball',ascending=False).head(10) #Sorts the batsmen in descending order based on the number of balls faced.

"""###Virat kohli had played the most balls.
###David Warner and Chris Gayle are the only two foreign players in this top 10 list.

#Q21) Who are the leading run-scorers of all time?
"""

# Group by 'batsman' and sum 'batsman_runs'
top_batsmen = ball.groupby('batsman')['batsman_runs'].sum().reset_index()

# Rename columns for clarity
top_batsmen.columns = ['Batsman', 'Runs']

# Sort by 'Runs' in descending order and select top 10
top_batsmen = top_batsmen.sort_values(by='Runs', ascending=False).head(10).reset_index(drop=True)

# Display the result
top_batsmen

colors = ['turquoise',] * 13
colors[0] = 'crimson'
fig=px.bar(x=top_batsmen['Batsman'],y=top_batsmen['Runs'],labels=dict(x="Player",y="Total Runs"),)
fig.update_layout(title="Top 10 leading run-scrorer",
                  titlefont={'size': 26},template='simple_white'
                  )
fig.update_traces(marker_line_color='black',
                  marker_line_width=2.5, opacity=1,marker_color=colors)
fig.show()

"""##Virat Kohli is the leading run scorer in IPL.

#Q22) Who has hit the most number of 4's?

###Here is the step by step approach to get the most number of 4's by batsmen.
"""

# Calculate runs per batsman
runs = ball.groupby('batsman')['batsman_runs'].sum().reset_index()

# Merge balls_played with runs on 'batsman'
balls_played = balls_played.merge(runs, on='batsman', how='outer')

# Filter ball_data for 4s
fours = ball[ball['batsman_runs'] == 4]

# Calculate number of 4s per batsman
runs_4 = fours.groupby('batsman').size().reset_index(name='4s')

# Sort by 4s in descending order and select top 10
top_4s = runs_4.sort_values(by='4s', ascending=False).head(10).reset_index(drop=True)

top_4s

"""###Shikhar Dhawan holds the record for most number of 4's

#Q23) Who has hit the most number of 6's?
"""

six=ball.groupby('batsman')['batsman_runs'].agg(lambda x: (x==6).sum()).reset_index() #Groups the data by 'batsman' and counts the number of sixes (6s) each batsman has hit using a lambda function.
six.columns=['Batsman','6s'] # Renames the columns for clarity.
six.sort_values(by='6s',ascending=False).head(10).reset_index().drop('index',axis=1) #Sorts the batsmen by the number of sixes in descending order and selects the top 10. Resets the index and drops the old index column

"""###Chris Gayle had smashed 349 sixes, most by any batsman.

#Q24) Who has the highest strike rate?
"""

player=pd.concat([runs,balls_played.iloc[:,1],runs_4.iloc[:,1],six.iloc[:,1]],axis=1) #Combines statistical data (runs, balls_played, runs_4, six) into one DataFrame (player).
player['strike_rate']=player['batsman_runs']/player['ball']*100 # Computes the strike rate for each batsman based on their total runs and balls faced.
player['4s'].fillna(0,inplace=True) #Ensures the '4s' column is populated with 0 where data is missing.
player.isnull().values.any() #Verifies if there are any remaining missing values in the player DataFrame.

player.sort_values(by='strike_rate',ascending=False).head(10)

"""This result shows the top 10 batsmen with the highest strike rates, sorted in descending order. It helps identify the most effective batsmen in terms of scoring quickly relative to the number of balls faced."""

sr=player[player.ball > 100]
sr.sort_values(by='strike_rate',ascending=False).head(10)

"""The combined expression sr=player[player.ball > 100]; sr.sort_values(by='strike_rate', ascending=False).head(10) efficiently filters the player DataFrame to include only batsmen who have faced more than 100 balls (sr) and then sorts these batsmen by their strike rates in descending order, displaying the top 10 batsmen."""

reqsr=sr.drop(columns=['batsman_runs','ball','4s','6s'],axis=1) #Drop Columns: Removes unnecessary columns ('batsman_runs', 'ball', '4s', '6s') from sr to focus only on the 'strike_rate' for clarity and analysis.
reqsr.sort_values(by='strike_rate',ascending=False).head(10) #Sorts the remaining data by 'strike_rate' and selects the top 10 batsmen, helping to identify the top performers in terms of strike rate after filtering by balls faced.

"""##Andre Russel has the highest strike rate, followed by K. Gowtham and B. Cutting.

#Q25) Who is the leading wicket-taker?
"""

# Group by player and sum the wickets
wicket_takers = ball.groupby('bowler')['is_wicket'].sum().reset_index()

wicket_takers

# Sort the players by the number of wickets in descending order
wicket_takers = wicket_takers.sort_values(by='is_wicket', ascending=False)

wicket_takers

# Get the leading wicket-taker
leading_wicket_taker = wicket_takers.iloc[0]
leading_wicket_taker

"""##L. Malinga is the leading wicket taker in IPL."""

# Select the top 10 wicket-takers
top_wicket_takers = wicket_takers.head(10)

# Create a list of colors
colors = ['turquoise'] * 10
colors[0] = 'crimson'


# Create the bar plot
fig = px.bar(x=top_wicket_takers['bowler'],
             y=top_wicket_takers['is_wicket'],
             labels=dict(x="Bowler", y="Total Wickets"))

fig.update_layout(title="Leading wicket-takers",
                  titlefont={'size': 26},
                  template='simple_white')

fig.update_traces(marker_line_color='black',
                  marker_line_width=2.5,
                  opacity=1,
                  marker_color=colors)

fig.show()

"""#Q26) Which stadium has hosted the most number of matches?


"""

# Group by stadium and count the number of matches
stadium_counts = matches['venue'].value_counts().reset_index()
stadium_counts.columns = ['venue', 'match_count']

# Find the stadium with the most matches
most_matches_stadium = stadium_counts.iloc[0]
print(f"The stadium that has hosted the most matches is {most_matches_stadium['venue']} with {most_matches_stadium['match_count']} matches.")

colors = ['turquoise',] * 13
colors[0] = 'crimson'
fig=px.bar(x=matches['venue'].value_counts()[:10].index,y=matches['venue'].value_counts()[:10],labels=dict(x="Venue",y="Match count"),)
fig.update_layout(title="Matches played at different stadiums",
                  titlefont={'size': 26},template='simple_white'
                  )
fig.update_traces(marker_line_color='black',
                  marker_line_width=2.5, opacity=1,marker_color=colors)
fig.show()

"""#Q27) Who has won the most MOM awards?


###Group the data by player and count the number of Man Of the Match(MOM) awards.
"""

# Group by player and count the number of MOM awards
mom_counts = matches['player_of_match'].value_counts().reset_index()
mom_counts.columns = ['player', 'mom_count']

# Find the player with the most MOM awards
most_mom_player = mom_counts.iloc[0]
print(f"The player with the most Man of the Match awards is {most_mom_player['player']} with {most_mom_player['mom_count']} awards.")

colors = ['turquoise',] * 11
colors[0] = 'crimson'
fig=px.bar(x=matches.player_of_match.value_counts()[:10].index,y=matches.player_of_match.value_counts()[:10],labels=dict(x="Players",y="Count"),)
fig.update_layout(title="Top 10 MOM awardee",
                  titlefont={'size': 26},template='simple_white'
                  )
fig.update_traces(marker_line_color='black',
                  marker_line_width=2.5, opacity=1,marker_color=colors)
fig.show()

"""#Q28) What is the count of fours hit in each season?"""

# Merge the datasets on match_id
merged_data = pd.merge(ball, matches, left_on='id', right_on='id')

merged_data.head()

# Filter for fours
fours_data = merged_data[merged_data['batsman_runs'] == 4]

# Group by season and count the number of fours
fours_count_per_season = fours_data.groupby('Season').size().reset_index(name='fours_count')

fours_count_per_season

four_per_season= fours_count_per_season.head(10)

colors = ['turquoise',] * 11
colors[5] = 'crimson'
fig=px.bar(x=four_per_season.Season.value_counts()[:10].index,y=four_per_season.fours_count[:10],labels=dict(x="Season",y="Total Fours"),)
fig.update_layout(title="Total number of Fours in each season",
                  titlefont={'size': 26},template='simple_white'
                  )
fig.update_traces(marker_line_color='black',
                  marker_line_width=2.5, opacity=1,marker_color=colors)
fig.show()

"""###Highest number of four in a season was is 2013 season while season 2009 had the lowest count of 4's.

#Q29) What is the count of sixes hit in each season?
"""

# Filter for fours
six_data = merged_data[merged_data['batsman_runs'] == 6]

# Group by season and count the number of six
six_count_per_season = six_data.groupby('Season').size().reset_index(name='six_count')

six_count_per_season

colors = ['turquoise',] * 13
colors[10] = 'crimson'
fig=px.bar(x=six_count_per_season.Season.value_counts().index,y=six_count_per_season.six_count,labels=dict(x="Season",y="Total Six"),)
fig.update_layout(title="Total number of Six in each season",
                  titlefont={'size': 26},template='simple_white'
                  )
fig.update_traces(marker_line_color='black',
                  marker_line_width=2.5, opacity=1,marker_color=colors)
fig.show()

"""###In season 2018, the maximum number of sixes were hit while the lowest was observed in season 2009.

#Q30) What is the count of runs scored from boundaries in each season?
###As in the earlier questions we have already counted the total number of 4 and 6 from each season, we don't have to calculate again, just take the dataframe for data analysis.
"""

# Filter for boundaries (fours and sixes)
boundaries_data = merged_data[merged_data['total_runs'].isin([4, 6])]

# Group by season and sum the runs from boundaries
boundary_runs_per_season = boundaries_data.groupby('Season')['total_runs'].sum().reset_index(name='boundary_runs')

# Print the results
print(boundary_runs_per_season)

# Plot the results
fig = px.bar(boundary_runs_per_season, x='Season', y='boundary_runs',
             labels={'season': 'Season', 'boundary_runs': 'Runs from Boundaries'},
             title='Runs Scored from Boundaries in Each IPL Season')

fig.show()

"""##Total run scored from boundaries is lowest in season 2009 and highest in season 2013.

#Q31) What is the run contribution from boundaries in each season?
"""

totruns=np.array(Season['total_runs']) #This line of code extracts the 'total_runs' column from the Season DataFrame and converts it into a NumPy array.

totruns

boundary_runs_per_season #checking for the columns so that we can extract only the necessary columns required.

# Extract only the Boundary_Runs column
boundary_runs = boundary_runs_per_season['boundary_runs']

boundary_runs #contains only the runs of 4 + 6 total.

boundary_run_percent=(boundary_runs/totruns)*100 #Calculating the percentage of the runs from the boundaries that contribute in the total runs.
boundary_run_percent #Result

Season #Checking the Season dataframe, so that we have to take only the relevant column.

season_df = pd.DataFrame(season_data) #Here we are extracting only the season column as we require season column.

season = season_df['Season']#Select the Season column

new_df = pd.concat([boundary_run_percent, Season], axis=1) #Merging the 2 columns and creating a new data frame to view the details clearly.

new_df

# Plot the results
fig = px.bar(new_df, x='Season', y='boundary_runs',
             labels={'season': 'Season', 'boundary_runs': 'Runs from Boundaries'},
             title='Runs Scored from Boundaries in Each IPL Season')

fig.show()

"""###In season 2018, 59.82 % runs of the total runs came from boundaries while 51.22 % runs came from boundaries in season 2009 which is lowest till now.

#Q32 Which team has scored the most runs in the first 6 overs?
"""

first_6_overs = ball[ball['over'] <= 6] #Filtering the data for the first 6 overs: Filtering the data to include only deliveries from the first 6 overs.

runs_per_team = first_6_overs.groupby('batting_team')['total_runs'].sum() # Grouping the data by the team and sum the runs scored in the first 6 overs.

runs_per_team #Display the result:

team_with_most_runs = runs_per_team.idxmax() #Finding the team with the maximum runs scored.
max_runs = runs_per_team.max()

print(f"The team with the most runs in the first 6 overs is {team_with_most_runs} with {max_runs} runs.")

data = {
    'batting_team': [
        'Chennai Super Kings', 'Deccan Chargers', 'Delhi Capitals', 'Delhi Daredevils',
        'Gujarat Lions', 'Kings XI Punjab', 'Kochi Tuskers Kerala', 'Kolkata Knight Riders',
        'Mumbai Indians', 'Pune Warriors', 'Rajasthan Royals', 'Rising Pune Supergiant',
        'Rising Pune Supergiants', 'Royal Challengers Bangalore', 'Sunrisers Hyderabad'
    ],
    'total_runs': [
        9266, 3889, 1788, 8492, 1812, 10248, 769, 10172, 10476, 2141,
        8231, 877, 744, 9909, 6700
    ]
}   #Create the DataFrame: Convert the runs_per_team data into a DataFrame with two columns: batting_team and total_runs.

df = pd.DataFrame(data) #Create the DataFrame: Convert the runs_per_team data into a DataFrame with two columns: batting_team and total_runs.

# Plotting the bar graph
fig = px.bar(df, x='batting_team', y='total_runs',
             labels={'batting_team': 'Batting Team', 'total_runs': 'Total Runs'},
             title='Total Runs Scored by Each Team in the First 6 Overs')

# Customize the layout for better readability
fig.update_layout(
    xaxis_tickangle=-45,
    xaxis_title='Batting Team',
    yaxis_title='Total Runs',
    title={'text': 'Total Runs Scored by Each Team in the First 6 Overs', 'x':0.5, 'xanchor': 'center'},
    template='plotly_white'
)

# Display the plot
fig.show()

"""#Q33)  Which team has scored the most runs in the last 4 overs?"""

# The last 4 overs are from over 17 to over 20
last_4_overs = ball[(ball['over'] >= 17) & (ball['over'] <= 20)]

#Group by team and sum the runs
runs_per_team = last_4_overs.groupby('batting_team')['total_runs'].sum()

#Identify the team with the most runs
team_with_most_runs = runs_per_team.idxmax()
max_runs = runs_per_team.max()

runs_per_team

#Display the result
print(f"The team with the most runs in the last 4 overs is {team_with_most_runs} with {max_runs} runs.")

# Create a DataFrame for plotting
plot_df = runs_per_team.reset_index()

# Plot the bar graph using Plotly
fig = px.bar(plot_df, x='batting_team', y='total_runs',
             labels={'batting_team': 'Batting Team', 'total_runs': 'Total Runs'},
             title='Total Runs Scored by Each Team in the Last 4 Overs')

# Customize the layout for better readability
fig.update_layout(
    xaxis_tickangle=-45,  # Rotate x-axis labels for better readability
    xaxis_title='Batting Team',
    yaxis_title='Total Runs',
    title={'text': 'Total Runs Scored by Each Team in the Last 4 Overs', 'x':0.5, 'xanchor': 'center'},
    template='plotly_white'  # Use a clean white background
)

"""#Q34) Which team has the best scoring run-rate in the first 6 overs?"""

first_6_overs = ball[ball['over'] <= 6]  #Filtering the data for the first 6 overs: Filtering the data to include only deliveries from the first 6 overs.

total_runs_per_team = first_6_overs.groupby('batting_team')['total_runs'].sum() # Grouping the data by the team and sum the runs scored in the first 6 overs.

total_runs_per_team #Displaying the result.

total_overs_per_team = first_6_overs.groupby('batting_team')['over'].count() / 6  # Convert deliveries to overs

# Compute the run-rate (runs per over)
run_rate = total_runs_per_team / total_overs_per_team

run_rate

#Identify the team with the best run-rate
team_with_best_run_rate = run_rate.idxmax()
best_run_rate = run_rate.max()

#Display the result
print(f"The team with the best scoring run-rate in the first 6 overs is {team_with_best_run_rate} with a run-rate of {best_run_rate:.2f}.")

# Create a DataFrame for plotting
run_rate = run_rate.reset_index()

run_rate.columns = ['batting_team', 'run_rate']

#Plot the bar graph using Plotly
fig = px.bar(run_rate, x='batting_team', y='run_rate',
             labels={'batting_team': 'Batting Team', 'run_rate': 'Run Rate'},
             title='Run Rate of Each Team in the First 6 Overs')

# Step 4: Customize the layout for better readability
fig.update_layout(
    xaxis_tickangle=-45,  # Rotate x-axis labels for better readability
    xaxis_title='Batting Team',
    yaxis_title='Run Rate',
    title={'text': 'Run Rate of Each Team in the First 6 Overs', 'x':0.5, 'xanchor': 'center'},
    template='plotly_white'  # Use a clean white background
)

# Display the plot
fig.show()

import plotly.express as px

# Pie chart of run-rates
fig = px.pie(run_rate, names='batting_team', values='run_rate',
             title='Run Rate Distribution of Each Team in the First 6 Overs')

# Customize the layout
fig.update_layout(
    title={'text': 'Run Rate Distribution of Each Team in the First 6 Overs', 'x':0.5, 'xanchor': 'center'},
    template='plotly_white'
)

# Display the plot
fig.show()

"""#Q35)  Which team has the best scoring run-rate in the last 4 overs?"""

# The last 4 overs are from over 17 to over 20
last_4_overs = ball[(ball['over'] >= 17) & (ball['over'] <= 20)]

#Group by team and sum the runs
runs_per_team = last_4_overs.groupby('batting_team')['total_runs'].sum()

runs_per_team

# Group by team and calculate the total runs scored
total_runs_last_4_overs_per_team = last_4_overs.groupby('batting_team')['total_runs'].sum()

# Count the number of deliveries and convert to overs (4 overs, so we count occurrences of the 'over' column)
# There are 4 overs, so we count the number of occurrences of the 'over' column
total_deliveries_last_4_overs_per_team = last_4_overs.groupby('batting_team')['over'].count()
total_overs_last_4_overs_per_team = total_deliveries_last_4_overs_per_team / 4 # Convert deliveries to overs

total_overs_last_4_overs_per_team

# Calculate the run-rate (runs per over)
run_rate_last_4_overs = total_runs_last_4_overs_per_team / total_overs_last_4_overs_per_team

run_rate_last_4_overs

# Create a DataFrame for plotting
plot_df = run_rate_last_4_overs.reset_index()
plot_df.columns = ['Team Name', 'Run Rate in Last 4 Overs']

# Find the team with the best (highest) run-rate
best_run_rate_team_index = plot_df['Run Rate in Last 4 Overs'].idxmax()
best_run_rate_team = plot_df.iloc[best_run_rate_team_index]['Team Name']

# Print the team with the best run-rate
print(f"The team with the best scoring run-rate in the last 4 overs is: {best_run_rate_team}")

# Define colors for the bar graph
colors = ['lightblue'] * len(plot_df)
colors[best_run_rate_team_index] = 'darkorange'

# Plot the bar graph using Plotly
fig = px.bar(plot_df, x='Team Name', y='Run Rate in Last 4 Overs',
             labels={'Team Name': 'Team Name', 'Run Rate in Last 4 Overs': 'Run Rate'},
             title='Run Rate in the Last 4 Overs')

# Update the layout and trace settings
fig.update_layout(
    title="Run Rate in the Last 4 Overs",
    titlefont={'size': 26},
    template='simple_white'
)
fig.update_traces(
    marker_line_color='black',  # Border color for the bars
    marker_line_width=2.5,  # Border width for the bars
    opacity=1,  # Full opacity for the bars
    marker_color=colors  # Set the colors for the bars
)